
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>nd</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-07-18"><meta name="DC.source" content="nd.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

/* html { min-height:100%; margin-bottom:1px; } */
html body { height:100%; margin:1em; font-family:Arial, Helvetica, sans-serif; font-size:12px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
/* html body td { vertical-align:top; text-align:left; } */

/* h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; } */

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

/* p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } */

/* ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; } */
/* ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; } */
/* ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; } */
/* ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; } */

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Code Report</h2><div><ul><li><a href="#1">[TIP8419 - Algebra Linear e Multilinear]</a></li><li><a href="#2">MATRIX OPERATIONS</a></li><li><a href="#3">TENSOR OPERATIONS</a></li><li><a href="#4">MATRIX PRODUCTS</a></li><li><a href="#5">TENSOR FACTORS ESTIMATION</a></li><li><a href="#6">TENSOR RESHAPE AND N-PRODUCT</a></li><li><a href="#7">TENSOR DECOMPOSTIONS</a></li><li><a href="#8">SAVE DATA TO TXT FILE</a></li></ul></div><h2 id="1">[TIP8419 - Algebra Linear e Multilinear]</h2><p>Author: Lucas Abdalah</p><p>ND is a package developped for the Multilinear Algebra Course It is a shortcut for N-d array in reference to the homonym library in python</p><p>CONTENT</p><pre class="language-matlab">MATRIX <span class="string">OPERATIONS</span>
    ND.VEC              - Vectorize a <span class="string">matrix.</span>
</pre><pre class="language-matlab">TENSOR <span class="string">OPERATIONS</span>
    ND.RANDN_COMPLEX    - Complex-valued array <span class="string">from</span> <span class="string">normal</span> <span class="string">distribution.</span>
    ND.NMSE             - Normalized mean <span class="string">square</span> <span class="string">error</span> <span class="string">(NMSE)</span> <span class="string">of</span> <span class="string">a</span> <span class="string">tensor.</span>
    ND.SLICEORT         - Verify the <span class="string">orthogonality</span> <span class="string">between</span> <span class="string">the</span>  <span class="string">slices</span> <span class="string">of</span> <span class="string">a</span> <span class="string">tensor</span>
    ND.SUPERDIAG        - Return a <span class="string">super</span> <span class="string">diagonal</span> <span class="string">3D</span> <span class="string">Tensor</span>
</pre><pre class="language-matlab">MATRIX <span class="string">PRODUCTS</span>
    ND.HADAMARD_    - Hadamard product <span class="string">with</span> <span class="string">two</span> <span class="string">matrices.</span>
    ND.KRON_        - Kronnecker product <span class="string">with</span> <span class="string">two</span> <span class="string">matrices.</span>
    ND.KR_          - Khatri-Rao product <span class="string">with</span> <span class="string">two</span> <span class="string">matrices.</span>
</pre><pre class="language-matlab">TENSOR <span class="string">FACTORS</span> <span class="string">ESTIMATION</span>
    ND.LSKRF        - Least-Squares Khatri-Rao Factorization (LSKRF)
    ND.LSKRONF      - Least-Squares  Kronecker <span class="string">Product</span> <span class="string">Factorization</span> <span class="string">(LSKRONF)</span>
    ND.KPSVD        - Kronecker Product <span class="string">Singular</span> <span class="string">Value</span> <span class="string">Decomposition</span> <span class="string">(KPSVD)</span>
</pre><pre class="language-matlab">TENSOR <span class="string">RESHAPE</span> <span class="string">AND</span> <span class="string">N-PRODUCT</span>
    ND.UNFOLD       - Unfold a <span class="string">tensor</span> <span class="string">into</span> <span class="string">N-mode</span> <span class="string">tensor</span> <span class="string">(matrix)</span>
    ND.FOLD         - Fold a <span class="string">N-mode</span> <span class="string">tensor</span> <span class="string">(matrix)</span> <span class="string">into</span> <span class="string">a</span> <span class="string">tensor</span>
    ND.N_MODE       - Compute the <span class="string">N-mode</span> <span class="string">product</span> <span class="string">bewteen</span> <span class="string">a</span> <span class="string">tensor</span> <span class="string">and</span> <span class="string">factor</span> <span class="string">matrices</span>
</pre><pre class="language-matlab">TENSOR <span class="string">DECOMPOSTIONS</span>
    ND.HOSVD        - Perfom the <span class="string">High</span> <span class="string">Order</span> <span class="string">Singular</span> <span class="string">Value</span> <span class="string">Decomposition</span> <span class="string">(HOSVD)</span> <span class="string">of</span> <span class="string">a</span> <span class="string">tensor</span>, truncated <span class="string">or</span> <span class="string">full</span> <span class="string">version</span>
    ND.HOOI         - Perfom the <span class="string">High</span> <span class="string">Order</span> <span class="string">Orthogonal</span> <span class="string">Iteration</span> <span class="string">(HOOI)</span> <span class="string">of</span> <span class="string">a</span> <span class="string">tensor</span>, truncated <span class="string">or</span> <span class="string">full</span> <span class="string">version</span>
    ND.MLSKRF       - Perform the <span class="string">Multidimensional</span> <span class="string">Least-Squares</span> <span class="string">Khatri-Rao</span> <span class="string">Factorization</span> <span class="string">(MLSKRF)</span> <span class="string">of</span> <span class="string">a</span> <span class="string">tensor</span>
    ND.MLSKRONF     -  Perform the <span class="string">Multidimensional</span> <span class="string">Least-Squares</span> <span class="string">Kronecker</span> <span class="string">Factorization</span> <span class="string">(MLS-KronF)</span> <span class="string">of</span> <span class="string">a</span> <span class="string">tensor</span>
    ND.ALS          - Perform the <span class="string">Alternating</span> <span class="string">Least-Squares</span> <span class="string">(ALS)</span> <span class="string">of</span> <span class="string">a</span> <span class="string">tensor</span>
</pre><pre class="language-matlab">SAVE <span class="string">DATA</span> <span class="string">TO</span> <span class="string">TXT</span> <span class="string">FILE</span>
    ND.MAT2TXT      - Write a <span class="string">matrix</span> <span class="string">X</span> <span class="string">into</span> <span class="string">a</span> <span class="string">txt</span> <span class="string">file</span>
    ND.TENSOR2TXT   - Write a <span class="string">3D</span> <span class="string">tensor</span> <span class="string">X</span> <span class="string">into</span> <span class="string">a</span> <span class="string">txt</span> <span class="string">file</span>
</pre><pre class="codeinput"><span class="keyword">classdef</span> nd

<span class="keyword">methods</span>(Static)
</pre><h2 id="2">MATRIX OPERATIONS</h2><pre class="codeinput">    <span class="keyword">function</span> y = vec(x)
        <span class="comment">% ND.VEC - Vectorize a matrix.</span>
        <span class="comment">%   y = vec(x) draws a vector from a given matrix.</span>
        <span class="comment">%</span>
        <span class="comment">%   See also.</span>
            y = x(:);
    <span class="keyword">end</span>
</pre><h2 id="3">TENSOR OPERATIONS</h2><pre class="codeinput">    <span class="keyword">function</span> C = randn_complex(M, varargin)
    <span class="comment">% ND.RANDN_COMPLEX - Complex-valued array from normal distribution.</span>
    <span class="comment">%   C = nd.randn_complex(M,N) draws a complex-valued array from normal</span>
    <span class="comment">%       distribution.</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
            C = complex(randn(M,varargin{:}), randn(M, varargin{:}));
    <span class="keyword">end</span>


    <span class="keyword">function</span> [X_nmse, X_nmse_dB] = nmse(X, X_hat)
    <span class="comment">% ND.NMSE - Normalized mean square error (NMSE) of a tensor.</span>
    <span class="comment">%   [X_nmse, X_nmse_dB] = nd.nmse(X, X_hat) compute the NMSE of two arrays</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        X_nmse = frob(X - X_hat)^2/(frob(X)^2);
        X_nmse_dB = db(X_nmse);
    <span class="keyword">end</span>


    <span class="keyword">function</span> f_ord = sliceort(Xten)
    <span class="comment">% ND.SLICEORT - Verify the orthogonality between slices of a tensor, by summing the</span>
    <span class="comment">%  the scalar between all the slices.</span>
    <span class="comment">%</span>
    <span class="comment">%   f_ord = sliceort(Xten) compute scalar product between tensor slices</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        size_Xten = size(Xten);
        f_ord = [];

        <span class="keyword">for</span> kk_xT = 1:size_Xten(3)
            <span class="keyword">for</span> kk_x = 1:size_Xten(3)
                <span class="keyword">if</span> kk_xT ~= kk_x
                    f_ord(end+1) = nd.vec(Xten(:,:,kk_xT))'*nd.vec(Xten(:,:,kk_x)) ;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        f_ord = sum(f_ord);
    <span class="keyword">end</span>


    <span class="keyword">function</span> X = superdiag(N)
    <span class="comment">% ND.SUPERDIAG - Return a super diagonal 3D Tensor</span>
    <span class="comment">%   X = nd.superdiag(N) draws a super diagonal 3D Tensor.</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        X = zeros(N,N,N);
        <span class="keyword">for</span> i = 1:N
            X(i,i,i) = 1;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><h2 id="4">MATRIX PRODUCTS</h2><pre class="codeinput">    <span class="keyword">function</span> [C, elaspedTime] = hadamard_(A, B)
    <span class="comment">% ND.HADAMARD_  Hadamard product with two matrices.</span>
    <span class="comment">%   C = nd.hadamard_(A, B) compute the hadamard procuct.</span>
    <span class="comment">%</span>
    <span class="comment">%   [C, elaspedTime] = nd.hadamard_(A, B) compute the hadamard</span>
    <span class="comment">%   procuct elapsed time.</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        tic;

        C = A.*B;

        elaspedTime = toc;
    <span class="keyword">end</span>


    <span class="keyword">function</span> [C, elaspedTime] = kron_(A, B)
    <span class="comment">% ND.KRON_  Kronnecker product with two matrices.</span>
    <span class="comment">%   C = nd.kron_(A, B) compute the Kronnecker procuct.</span>
    <span class="comment">%</span>
    <span class="comment">%   [C, elaspedTime] = nd.kron_(A, B) compute the Kronnecker</span>
    <span class="comment">%   procuct elapsed time.</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        tic;

        <span class="comment">% [M_rows, N_columns] = size(B);</span>
        <span class="comment">% C = repelem(A, M_rows, N_columns).*repmat(B,[size(A)]);</span>

        C = kron(A,B);

        elaspedTime = toc;
    <span class="keyword">end</span>


    <span class="keyword">function</span> [C, elaspedTime] = kr_(A, B)
    <span class="comment">% ND.KR_  Khatri-Rao product with two matrices.</span>
    <span class="comment">%   C = nd.kr_(A, B) compute the Khatri-Rao procuct.</span>
    <span class="comment">%</span>
    <span class="comment">%   [C, elaspedTime] = nd.kr_(A, B) compute the Khatri-Rao</span>
    <span class="comment">%   procuct elapsed time.</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        tic;

        N = size(A,2);
        <span class="keyword">if</span> N == size(B,2)
            P = reshape(A,1,[],N);
            Q = reshape(B,[],1,N);
            C = P.*Q;
            C = reshape(C,[],N);
        <span class="keyword">else</span>
            error(<span class="string">'number of columns should be equal'</span>)
        <span class="keyword">end</span>

        elaspedTime = toc;
    <span class="keyword">end</span>
</pre><h2 id="5">TENSOR FACTORS ESTIMATION</h2><pre class="codeinput">    <span class="keyword">function</span> [Ahat,Bhat] = lskrf(X, M, N)
    <span class="comment">% ND.LSKRF  Least-Squares Khatri-Rao Factorization (LSKRF)</span>
    <span class="comment">%   [Ahat,Bhat] = nd.lskrf(X, M, N) compute the LSKRF.</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        [iX, jX] = size(X);

        <span class="keyword">if</span> iX == M*N <span class="comment">% Verify the input dimensions</span>
            Ahat = complex(zeros(M,jX),0);
            Bhat = complex(zeros(N,jX),0);

            <span class="keyword">for</span> jj = 1:jX
                [U,S,V] = svd(reshape(X(:,jj), [N M]));
                Ahat(:,jj) = sqrt(S(1,1)).*conj(V(:,1));
                Bhat(:,jj) = sqrt(S(1,1)).*U(:,1);
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            error(<span class="string">'number of rows of X should be equal to size M*N'</span>);
        <span class="keyword">end</span>

    <span class="keyword">end</span>


    <span class="keyword">function</span> [Ahat,Bhat] = lskronf(X, Ma, Na, Mb, Nb)
    <span class="comment">% ND.LSKRONF  Least-Squares Kronecker Product Factorization (LSKRONF)</span>
    <span class="comment">%   [Ahat,Bhat] = nd.lskronf(X, Ma, Na, Mb, Nb) compute the LSKRONF.</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        [Mx,Nx] = size(X);

        <span class="keyword">if</span> Ma*Mb == Mx &amp;&amp; Na*Nb == Nx <span class="comment">% Verify the input dimensions</span>
            Xhat = complex(zeros(Mb*Nb,Ma*Na),0);
            X_b = mat2cell(X, repelem(Mx/Ma,Ma), repelem(Nx/Na,Na));

            itCol = 1;
            <span class="keyword">for</span> jj = 1:Na
                <span class="keyword">for</span> ii = 1:Ma
                    Xhat(:,itCol) = nd.vec(cell2mat(X_b(ii,jj)));
                    itCol = itCol + 1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            [U,S,V] = svd(Xhat);
            Ahat = reshape(sqrt(S(1,1)).*conj(V(:,1)),[Ma Na]);
            Bhat = reshape(sqrt(S(1,1)).*U(:,1), [Mb Nb]);

        <span class="keyword">else</span>
            error(<span class="string">'size of X(Mx, Nx) should match with Mc=Ma*Mb and Nc=Na*Nb, A(Ma, Na) and B(Mb, Nb)'</span>);
        <span class="keyword">end</span>
    <span class="keyword">end</span>


    <span class="keyword">function</span> [U,S,V,rkp] = kpsvd(X, Xstruct)
    <span class="comment">% ND.KPSVD  Kronecker Product Singular Value Decomposition (KPSVD)</span>
    <span class="comment">%   [U,S,V,rkp] = nd.kpsvd(X, Xstruct) compute the KPSVD.</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        [Mx,Nx] = size(X);

        <span class="keyword">if</span> Xstruct(1)*Xstruct(3) == Mx &amp;&amp; Xstruct(2)*Xstruct(4) == Nx <span class="comment">% Verify the input dimensions</span>
            Xhat = complex(zeros(Xstruct(3)*Xstruct(4),Xstruct(1)*Xstruct(2)),0);
            X_b = mat2cell(X, repelem(Mx/Xstruct(1),Xstruct(1)), repelem(Nx/Xstruct(2),Xstruct(2)));

            itCol = 1;
            <span class="keyword">for</span> jj = 1:Xstruct(2)
                <span class="keyword">for</span> ii = 1:Xstruct(1)
                    Xhat(:,itCol) = nd.vec(cell2mat(X_b(ii,jj)));
                    itCol = itCol + 1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            [U,S,V] = svd(Xhat');
            rkp = rank(S);
        <span class="keyword">else</span>
            error(<span class="string">'size of X(Mx, Nx) should match with Mc=Xstruct(1)*Xstruct(3) and Nc=Xstruct(2)*Xstruct(4), for A(Xstruct(1), Xstruct(2)) and B(Xstruct(3), Xstruct(4))'</span>);
        <span class="keyword">end</span>

    <span class="keyword">end</span>
</pre><h2 id="6">TENSOR RESHAPE AND N-PRODUCT</h2><pre class="codeinput">    <span class="keyword">function</span> Xn = unfold(Xten,N_mode)
    <span class="comment">% ND.UNFOLD  Unfold a tensor into N-mode tensor (matrix)</span>
    <span class="comment">%   Xn = unfold(Xten,N_mode) compute into N-mode tensor</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        Xten_Size = size(Xten);
        reSort = 1:1:numel(Xten_Size); <span class="comment">% prod(size(Xten_Size))</span>
        reSort(N_mode) = [];
        Xn = reshape(permute(Xten,[N_mode reSort]), <span class="keyword">...</span>
                    [], <span class="keyword">...</span>
                    prod(Xten_Size)/Xten_Size(N_mode));
    <span class="keyword">end</span>


    <span class="keyword">function</span> Xten = fold(Xn,Xten_Size,N_mode)
    <span class="comment">% ND.FOLD  Fold a N-mode tensor (matrix) into a tensor</span>
    <span class="comment">%   Xn = fold(Xn,Xten_Size,N_mode) fold a Xn into X tensor</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        reSort = 1:1:numel(Xten_Size);
        reSort(N_mode) = [];
        reSort = [N_mode reSort];
        Xten = reshape(Xn,Xten_Size(reSort));

        <span class="keyword">switch</span> N_mode
            <span class="keyword">case</span> 1
                Xten = permute(Xten,reSort);
            <span class="keyword">otherwise</span>
                reSort = 1:numel(Xten_Size);
                <span class="keyword">for</span> ii = 2:N_mode
                    reSort([ii-1, ii]) = reSort([ii, ii-1]);
                <span class="keyword">end</span>
                Xten = permute(Xten,reSort);
        <span class="keyword">end</span>
    <span class="keyword">end</span>


    <span class="keyword">function</span> Yten = N_mode(Xten,factors,N_mode)
    <span class="comment">% ND.N_MODE  Compute the N-mode product bewteen a tensor and factor matrices</span>
    <span class="comment">%   Yten = N_mode(Xten,factors,N_mode) N-mode product bewteen a tensor and matrices</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        <span class="keyword">if</span> nargin &lt; 3
            N_mode = 1:numel(factors);
        <span class="keyword">end</span>
        Xten_Size = size(Xten);
        <span class="keyword">for</span> nIt = N_mode
            [Xten_Size(nIt), ~] = size(cell2mat(factors(nIt)));
            Yten = nd.fold(cell2mat(factors(nIt))*nd.unfold(Xten,nIt), <span class="keyword">...</span>
                            Xten_Size, <span class="keyword">...</span>
                            nIt);
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><h2 id="7">TENSOR DECOMPOSTIONS</h2><pre class="codeinput">    <span class="keyword">function</span> [S, U] = hosvd(ten, Atype, ranksInput)
    <span class="comment">% ND.HOSVD  Perfom the High Order Singular Value Decomposition (HOSVD)</span>
    <span class="comment">%  of a tensor, truncated or full version.</span>
    <span class="comment">%   [S,U] = hosvd(ten, 'trunc') compute the truncated-HOSVD</span>
    <span class="comment">%   [S,U] = hosvd(ten, 'full') compute the full-HOSVD</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        N = numel(size(ten));
        U = cell(N, 1);

        <span class="keyword">switch</span> Atype
        <span class="keyword">case</span> <span class="string">'trunc'</span>
                <span class="keyword">for</span> i = 1:N
                    [Ur, Sr, ~] = svd(nd.unfold(ten,i));
                    <span class="keyword">if</span> nargin &lt; 3
                        Ur = Ur(:,1:rank(Sr));
                    <span class="keyword">else</span>
                        Ur = Ur(:,1:ranksInput(i));
                    <span class="keyword">end</span>
                    U{i} = Ur;
                <span class="keyword">end</span>
        <span class="keyword">case</span> <span class="string">'full'</span>
            <span class="keyword">for</span> i = 1:N
                [Ur,~,~] = svd(nd.unfold(ten,i));
                U{i} = Ur;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        S = nd.N_mode(ten, (cellfun(@(x) x', U,<span class="string">'UniformOutput'</span>,false)));
        U = cellfun(@(x) x, U, <span class="string">'UniformOutput'</span>,false);
    <span class="keyword">end</span>


    <span class="keyword">function</span> [S, U, it] = hooi(ten, Atype, maxIt, ranksInput)
    <span class="comment">% ND.HOOI  Perfom the High Order Orthogonal Iteration (HOOI)</span>
    <span class="comment">%   of a tensor, truncated or full version.</span>
    <span class="comment">%</span>
    <span class="comment">%   [S,U] = hooi(ten, 'trunc') compute the truncated-HOOI</span>
    <span class="comment">%   [S,U] = hooi(ten, 'full') compute the full-HOOI</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        N = numel(size(ten));
        [~, U_ten] = nd.hosvd(ten, <span class="string">'full'</span>);

        <span class="keyword">if</span> nargin &lt; 3
            maxIt = 20;
        <span class="keyword">end</span>

        <span class="keyword">switch</span> Atype
        <span class="keyword">case</span> <span class="string">'trunc'</span>
            <span class="keyword">for</span> it = 1:maxIt
                <span class="keyword">for</span> ii = 1:N
                    N_mode = 1:N;
                    N_mode(ii) = [];
                    Un = nd.N_mode(ten, U_ten, N_mode);
                    [Ur, Sr, ~] = svd(nd.unfold(Un,ii));
                    <span class="keyword">if</span> nargin &lt; 3
                        U{ii} = Ur(:,1:rank(Sr));
                    <span class="keyword">else</span>
                        U{ii} = Ur(:,1:ranksInput(ii));
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">case</span> <span class="string">'full'</span>
            <span class="keyword">for</span> it = 1:maxIt
                <span class="keyword">for</span> ii = 1:N
                    N_mode = 1:N;
                    N_mode(ii) = [];
                    Un = nd.N_mode(ten, U_ten, N_mode);
                    [Usvd,~,~] = svd(nd.unfold(Un,ii));
                    U{ii} = Usvd;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        S = nd.N_mode(ten, cellfun(@(x) x', U, <span class="string">'UniformOutput'</span>, false)) ;
    <span class="keyword">end</span>


    <span class="keyword">function</span> factors = mlskrf(X, N_mode, order)
    <span class="comment">% ND.MLSKRF  Perform the Multidimensional Least-Squares Khatri-Rao</span>
    <span class="comment">%   Factorization (MLSKRF) of a tensor.</span>
    <span class="comment">%</span>
    <span class="comment">%   factors = mlskrf(X, N_mode, order) compute the MLSKRF of a tensor</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        [~,R] = size(X);
        factors = cell(N_mode, 1);
        factors_r = cell(R, N_mode);
        <span class="keyword">for</span> rr = 1:R
            [Sr,Ur] = nd.hosvd(reshape(X(:,rr), flip(order)), <span class="string">'full'</span>);
            <span class="keyword">for</span> nn = 1:N_mode
                sr = (Sr(1)^(1/N_mode));
                ur = Ur{N_mode-nn+1}(:,1);
                factors_r{rr,nn} = sr*ur;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        <span class="keyword">for</span> n = 1:N_mode
           factors{n} = reshape(cell2mat(factors_r(:,n)) ,[order(n) R]);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">function</span> Ahat = mlskronf(X, rowsInput, colsInput, Atype)
    <span class="comment">% ND.MLSKRONF  Perform the Multidimensional Least-Squares Kronecker</span>
    <span class="comment">%   Factorization (MLS-KronF) of a tensor.</span>
    <span class="comment">%</span>
    <span class="comment">%   factors = mlskronf(X, rowsInput, colsInput, Atype) compute the MLSKRF of a tensor</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        dim = {repelem(rowsInput(2)*rowsInput(3), 1, rowsInput(1)); repelem(colsInput(2)*colsInput(3), 1, colsInput(1))};
        Xb = mat2cell(X,dim{1},dim{2});
        Inv = {flip(rowsInput), flip(colsInput)};
        K = 1;

        <span class="keyword">for</span> jA = 1:colsInput(1)
            <span class="keyword">for</span> iA = 1:rowsInput(1)
                dim = {repelem(rowsInput(3), 1, rowsInput(2)), repelem(colsInput(3), 1, colsInput(2))};
                X_bc = mat2cell(cell2mat(Xb(iA,jA)), dim{1}, dim{2});
                <span class="keyword">for</span> jB = 1:colsInput(2)
                    <span class="keyword">for</span> iB = 1:rowsInput(2)
                        vb(:,iB,jB) = nd.vec(cell2mat(X_bc(iB,jB)));
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                Xhat(:,K) = reshape(vb,[],1);
                K = K + 1;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">switch</span> Atype
        <span class="keyword">case</span> <span class="string">'hosvd'</span>
            [S,U] = nd.hosvd(reshape(Xhat, flip(rowsInput.* colsInput)), <span class="string">'full'</span>);
        <span class="keyword">case</span> <span class="string">'hooi'</span>
            [S,U] = nd.hooi(reshape(Xhat, flip(rowsInput.* colsInput)), <span class="string">'full'</span>);
        <span class="keyword">end</span>

        UN = length(U);

        <span class="keyword">for</span> u = 1:UN
            Ahat{UN - u + 1} = reshape((S(1)^(1/length(U)))*U{u}(:,1), [Inv{1}(u) Inv{2}(u)]);
        <span class="keyword">end</span>
    <span class="keyword">end</span>


    <span class="keyword">function</span> [Ahat, Bhat, Chat, error, it] = als(X, R, tol, maxIt)
    <span class="comment">% ND.ALS  Perform the Alternating Least-Squares (ALS) of a tensor.</span>
    <span class="comment">%</span>
    <span class="comment">%   [Ahat, Bhat, Chat, error, it] = als(X, R, maxIt) compute the MLSKRF of a tensor</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>

        <span class="keyword">if</span> nargin &lt; 4
            maxIt = 200;
            <span class="keyword">if</span> nargin &lt; 3
                tol = 1e-6;
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        I = size(X);
        Ahat = nd.randn_complex(I(1), R);
        Bhat = nd.randn_complex(I(2), R);
        Chat = nd.randn_complex(I(3), R);
        X_1 = nd.unfold(X,1);
        X_2 = nd.unfold(X,2);
        X_3 = nd.unfold(X,3);

        error = zeros(1,maxIt);
        [error(1), ~] = nd.nmse(X_1, Ahat*(nd.kr_(Chat,Bhat).'));

        <span class="keyword">for</span> i = 2:maxIt
            Bhat = X_2*pinv((nd.kr_(Chat,Ahat)).');
            Chat = X_3*pinv((nd.kr_(Bhat,Ahat)).');
            Ahat = X_1*pinv((nd.kr_(Chat,Bhat)).');
            [error(i), ~] = nd.nmse(X_1, Ahat*(nd.kr_(Chat,Bhat).'));

            <span class="keyword">if</span> abs(error(i) - error(i-1)) &lt; tol
                error = error(1:i);
                it = i;
                <span class="keyword">break</span>;
            <span class="keyword">else</span>
                it = i;
                <span class="keyword">continue</span>;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><h2 id="8">SAVE DATA TO TXT FILE</h2><pre class="codeinput">    <span class="keyword">function</span> mat2txt(file, X, permission, header)
    <span class="comment">% ND.MAT2TXT  Write a matrix X into a txt file</span>
    <span class="comment">%   mat2txt(file, X, 'w', header) - Overwite the file</span>
    <span class="comment">%   mat2txt(file, X, 'a', header) - Append to the file end</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        [I, J] = size(X);
        fileID = fopen(file, permission);
        fprintf(fileID, [repelem(<span class="string">'-'</span>, strlength(header)+3), <span class="string">'\n'</span>, header, <span class="keyword">...</span>
                <span class="string">'\n'</span>, repelem(<span class="string">'-'</span>, strlength(header)+3), <span class="string">'\n'</span>]);
        fprintf(fileID, <span class="string">'X(%d, %d)\n'</span>, I, J);
            <span class="keyword">for</span> ii = 1:I
                <span class="keyword">for</span> jj = 1:J
                    fprintf(fileID, <span class="string">' %2.0f'</span>, X(ii,jj));
                <span class="keyword">end</span>
                fprintf(fileID, <span class="string">';\n'</span>);
            <span class="keyword">end</span>
        fprintf(fileID, <span class="string">'\n'</span>);
        fclose(fileID);
    <span class="keyword">end</span>


    <span class="keyword">function</span> tensor2txt(file, X, permission, header)
    <span class="comment">% ND.TENSOR2TXT  Write a 3D tensor X into a txt file</span>
    <span class="comment">%   tensor2txt(file, X, 'w', header) - Overwite the file</span>
    <span class="comment">%   tensor2txt(file, X, 'a', header) - Append to the file end</span>
    <span class="comment">%</span>
    <span class="comment">%   See also.</span>
        [I, J, K] = size(X);

        fileID = fopen(file, permission);

        fprintf(fileID, [repelem(<span class="string">'-'</span>, strlength(header)+3), <span class="string">'\n'</span>, header, <span class="keyword">...</span>
        <span class="string">'\n'</span>, repelem(<span class="string">'-'</span>, strlength(header)+3), <span class="string">'\n'</span>]);

        <span class="keyword">for</span> kk = 1:K
            fprintf(fileID, <span class="string">'X(:, :, %d)\n'</span>, kk);
            <span class="keyword">for</span> ii = 1:I
                <span class="keyword">for</span> jj = 1:J
                    fprintf(fileID, <span class="string">' %2.0f'</span>, X(ii,jj,kk));
                <span class="keyword">end</span>
                fprintf(fileID, <span class="string">';\n'</span>);
            <span class="keyword">end</span>
            fprintf(fileID, <span class="string">'\n'</span>);
        <span class="keyword">end</span>
        fclose(fileID);
    <span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>

<span class="keyword">end</span>
</pre><pre class="codeoutput">
ans = 

  nd with no properties.

</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% [TIP8419 - Algebra Linear e Multilinear]
% Author: Lucas Abdalah
% 
% ND is a package developped for the Multilinear Algebra Course
% It is a shortcut for N-d array in reference to the homonym library in python
%
% CONTENT
% 
%   MATRIX OPERATIONS
%       ND.VEC              - Vectorize a matrix.
% 
%   TENSOR OPERATIONS
%       ND.RANDN_COMPLEX    - Complex-valued array from normal distribution.
%       ND.NMSE             - Normalized mean square error (NMSE) of a tensor.
%       ND.SLICEORT         - Verify the orthogonality between the  slices of a tensor
%       ND.SUPERDIAG        - Return a super diagonal 3D Tensor
% 
%   MATRIX PRODUCTS
%       ND.HADAMARD_    - Hadamard product with two matrices.
%       ND.KRON_        - Kronnecker product with two matrices.
%       ND.KR_          - Khatri-Rao product with two matrices.
%
%   TENSOR FACTORS ESTIMATION
%       ND.LSKRF        - Least-Squares Khatri-Rao Factorization (LSKRF)
%       ND.LSKRONF      - Least-Squares  Kronecker Product Factorization (LSKRONF)
%       ND.KPSVD        - Kronecker Product Singular Value Decomposition (KPSVD)
%
%   TENSOR RESHAPE AND N-PRODUCT
%       ND.UNFOLD       - Unfold a tensor into N-mode tensor (matrix)
%       ND.FOLD         - Fold a N-mode tensor (matrix) into a tensor
%       ND.N_MODE       - Compute the N-mode product bewteen a tensor and factor matrices
% 
% 
%   TENSOR DECOMPOSTIONS
%       ND.HOSVD        - Perfom the High Order Singular Value Decomposition (HOSVD) of a tensor, truncated or full version
%       ND.HOOI         - Perfom the High Order Orthogonal Iteration (HOOI) of a tensor, truncated or full version
%       ND.MLSKRF       - Perform the Multidimensional Least-Squares Khatri-Rao Factorization (MLSKRF) of a tensor
%       ND.MLSKRONF     -  Perform the Multidimensional Least-Squares Kronecker Factorization (MLS-KronF) of a tensor
%       ND.ALS          - Perform the Alternating Least-Squares (ALS) of a tensor
%   
% 
%   SAVE DATA TO TXT FILE 
%       ND.MAT2TXT      - Write a matrix X into a txt file
%       ND.TENSOR2TXT   - Write a 3D tensor X into a txt file
%
% 

classdef nd

methods(Static)
    
    %% MATRIX OPERATIONS
    function y = vec(x)
        % ND.VEC - Vectorize a matrix.
        %   y = vec(x) draws a vector from a given matrix.
        % 
        %   See also.
            y = x(:);
    end
    
    
    %% TENSOR OPERATIONS
    function C = randn_complex(M, varargin)
    % ND.RANDN_COMPLEX - Complex-valued array from normal distribution.
    %   C = nd.randn_complex(M,N) draws a complex-valued array from normal 
    %       distribution.
    % 
    %   See also.
            C = complex(randn(M,varargin{:}), randn(M, varargin{:}));
    end

    
    function [X_nmse, X_nmse_dB] = nmse(X, X_hat)
    % ND.NMSE - Normalized mean square error (NMSE) of a tensor.
    %   [X_nmse, X_nmse_dB] = nd.nmse(X, X_hat) compute the NMSE of two arrays
    % 
    %   See also.
        X_nmse = frob(X - X_hat)^2/(frob(X)^2);
        X_nmse_dB = db(X_nmse);
    end


    function f_ord = sliceort(Xten)
    % ND.SLICEORT - Verify the orthogonality between slices of a tensor, by summing the
    %  the scalar between all the slices.
    % 
    %   f_ord = sliceort(Xten) compute scalar product between tensor slices
    % 
    %   See also.
        size_Xten = size(Xten);    
        f_ord = [];

        for kk_xT = 1:size_Xten(3)
            for kk_x = 1:size_Xten(3)
                if kk_xT ~= kk_x
                    f_ord(end+1) = nd.vec(Xten(:,:,kk_xT))'*nd.vec(Xten(:,:,kk_x)) ;
                end
            end
        end
        f_ord = sum(f_ord);
    end


    function X = superdiag(N)
    % ND.SUPERDIAG - Return a super diagonal 3D Tensor
    %   X = nd.superdiag(N) draws a super diagonal 3D Tensor.
    % 
    %   See also.
        X = zeros(N,N,N);
        for i = 1:N
            X(i,i,i) = 1;
        end
    end


    %% MATRIX PRODUCTS
    function [C, elaspedTime] = hadamard_(A, B)
    % ND.HADAMARD_  Hadamard product with two matrices.
    %   C = nd.hadamard_(A, B) compute the hadamard procuct.
    %
    %   [C, elaspedTime] = nd.hadamard_(A, B) compute the hadamard 
    %   procuct elapsed time.
    %
    %   See also.
        tic;
        
        C = A.*B;
        
        elaspedTime = toc;
    end


    function [C, elaspedTime] = kron_(A, B)
    % ND.KRON_  Kronnecker product with two matrices.
    %   C = nd.kron_(A, B) compute the Kronnecker procuct.
    %
    %   [C, elaspedTime] = nd.kron_(A, B) compute the Kronnecker 
    %   procuct elapsed time.
    %
    %   See also.
        tic;
        
        % [M_rows, N_columns] = size(B);
        % C = repelem(A, M_rows, N_columns).*repmat(B,[size(A)]);
        
        C = kron(A,B);

        elaspedTime = toc;
    end


    function [C, elaspedTime] = kr_(A, B)
    % ND.KR_  Khatri-Rao product with two matrices.
    %   C = nd.kr_(A, B) compute the Khatri-Rao procuct.
    %
    %   [C, elaspedTime] = nd.kr_(A, B) compute the Khatri-Rao 
    %   procuct elapsed time.
    %
    %   See also.
        tic;
        
        N = size(A,2);
        if N == size(B,2)
            P = reshape(A,1,[],N);
            Q = reshape(B,[],1,N);
            C = P.*Q;
            C = reshape(C,[],N);
        else
            error('number of columns should be equal')
        end

        elaspedTime = toc;
    end


    %% TENSOR FACTORS ESTIMATION
    function [Ahat,Bhat] = lskrf(X, M, N)
    % ND.LSKRF  Least-Squares Khatri-Rao Factorization (LSKRF)
    %   [Ahat,Bhat] = nd.lskrf(X, M, N) compute the LSKRF.
    %
    %   See also.
        [iX, jX] = size(X);

        if iX == M*N % Verify the input dimensions
            Ahat = complex(zeros(M,jX),0);
            Bhat = complex(zeros(N,jX),0);

            for jj = 1:jX
                [U,S,V] = svd(reshape(X(:,jj), [N M]));
                Ahat(:,jj) = sqrt(S(1,1)).*conj(V(:,1));
                Bhat(:,jj) = sqrt(S(1,1)).*U(:,1);
            end
        else
            error('number of rows of X should be equal to size M*N');
        end
    
    end
    
    
    function [Ahat,Bhat] = lskronf(X, Ma, Na, Mb, Nb)
    % ND.LSKRONF  Least-Squares Kronecker Product Factorization (LSKRONF)
    %   [Ahat,Bhat] = nd.lskronf(X, Ma, Na, Mb, Nb) compute the LSKRONF.
    %
    %   See also.   
        [Mx,Nx] = size(X);
        
        if Ma*Mb == Mx && Na*Nb == Nx % Verify the input dimensions 
            Xhat = complex(zeros(Mb*Nb,Ma*Na),0);    
            X_b = mat2cell(X, repelem(Mx/Ma,Ma), repelem(Nx/Na,Na));
            
            itCol = 1;
            for jj = 1:Na
                for ii = 1:Ma
                    Xhat(:,itCol) = nd.vec(cell2mat(X_b(ii,jj)));
                    itCol = itCol + 1;
                end
            end

            [U,S,V] = svd(Xhat);
            Ahat = reshape(sqrt(S(1,1)).*conj(V(:,1)),[Ma Na]);
            Bhat = reshape(sqrt(S(1,1)).*U(:,1), [Mb Nb]);

        else
            error('size of X(Mx, Nx) should match with Mc=Ma*Mb and Nc=Na*Nb, A(Ma, Na) and B(Mb, Nb)');
        end
    end


    function [U,S,V,rkp] = kpsvd(X, Xstruct)
    % ND.KPSVD  Kronecker Product Singular Value Decomposition (KPSVD)
    %   [U,S,V,rkp] = nd.kpsvd(X, Xstruct) compute the KPSVD.
    %
    %   See also.   
        [Mx,Nx] = size(X);
        
        if Xstruct(1)*Xstruct(3) == Mx && Xstruct(2)*Xstruct(4) == Nx % Verify the input dimensions 
            Xhat = complex(zeros(Xstruct(3)*Xstruct(4),Xstruct(1)*Xstruct(2)),0);    
            X_b = mat2cell(X, repelem(Mx/Xstruct(1),Xstruct(1)), repelem(Nx/Xstruct(2),Xstruct(2)));
            
            itCol = 1;
            for jj = 1:Xstruct(2)
                for ii = 1:Xstruct(1)
                    Xhat(:,itCol) = nd.vec(cell2mat(X_b(ii,jj)));
                    itCol = itCol + 1;
                end
            end
            [U,S,V] = svd(Xhat');
            rkp = rank(S);
        else
            error('size of X(Mx, Nx) should match with Mc=Xstruct(1)*Xstruct(3) and Nc=Xstruct(2)*Xstruct(4), for A(Xstruct(1), Xstruct(2)) and B(Xstruct(3), Xstruct(4))');
        end

    end
    

    %% TENSOR RESHAPE AND N-PRODUCT
    function Xn = unfold(Xten,N_mode)
    % ND.UNFOLD  Unfold a tensor into N-mode tensor (matrix)
    %   Xn = unfold(Xten,N_mode) compute into N-mode tensor
    %
    %   See also.
        Xten_Size = size(Xten);    
        reSort = 1:1:numel(Xten_Size); % prod(size(Xten_Size))
        reSort(N_mode) = [];        
        Xn = reshape(permute(Xten,[N_mode reSort]), ...
                    [], ...
                    prod(Xten_Size)/Xten_Size(N_mode));
    end


    function Xten = fold(Xn,Xten_Size,N_mode)
    % ND.FOLD  Fold a N-mode tensor (matrix) into a tensor
    %   Xn = fold(Xn,Xten_Size,N_mode) fold a Xn into X tensor
    %
    %   See also.
        reSort = 1:1:numel(Xten_Size);
        reSort(N_mode) = [];
        reSort = [N_mode reSort];
        Xten = reshape(Xn,Xten_Size(reSort));
        
        switch N_mode
            case 1
                Xten = permute(Xten,reSort);
            otherwise
                reSort = 1:numel(Xten_Size);
                for ii = 2:N_mode
                    reSort([ii-1, ii]) = reSort([ii, ii-1]);
                end
                Xten = permute(Xten,reSort);
        end
    end


    function Yten = N_mode(Xten,factors,N_mode)
    % ND.N_MODE  Compute the N-mode product bewteen a tensor and factor matrices
    %   Yten = N_mode(Xten,factors,N_mode) N-mode product bewteen a tensor and matrices
    %
    %   See also.
        if nargin < 3
            N_mode = 1:numel(factors); 
        end
        Xten_Size = size(Xten);
        for nIt = N_mode
            [Xten_Size(nIt), ~] = size(cell2mat(factors(nIt)));
            Yten = nd.fold(cell2mat(factors(nIt))*nd.unfold(Xten,nIt), ...
                            Xten_Size, ...
                            nIt);
        end
    end    


    %% TENSOR DECOMPOSTIONS
    function [S, U] = hosvd(ten, Atype, ranksInput)
    % ND.HOSVD  Perfom the High Order Singular Value Decomposition (HOSVD)
    %  of a tensor, truncated or full version.
    %   [S,U] = hosvd(ten, 'trunc') compute the truncated-HOSVD
    %   [S,U] = hosvd(ten, 'full') compute the full-HOSVD
    %
    %   See also.
        N = numel(size(ten));
        U = cell(N, 1);
        
        switch Atype
        case 'trunc'
                for i = 1:N
                    [Ur, Sr, ~] = svd(nd.unfold(ten,i)); 
                    if nargin < 3
                        Ur = Ur(:,1:rank(Sr));
                    else
                        Ur = Ur(:,1:ranksInput(i));    
                    end
                    U{i} = Ur;
                end
        case 'full'
            for i = 1:N
                [Ur,~,~] = svd(nd.unfold(ten,i)); 
                U{i} = Ur;
            end
        end
        S = nd.N_mode(ten, (cellfun(@(x) x', U,'UniformOutput',false)));
        U = cellfun(@(x) x, U, 'UniformOutput',false);
    end

    
    function [S, U, it] = hooi(ten, Atype, maxIt, ranksInput)
    % ND.HOOI  Perfom the High Order Orthogonal Iteration (HOOI)
    %   of a tensor, truncated or full version.
    %
    %   [S,U] = hooi(ten, 'trunc') compute the truncated-HOOI
    %   [S,U] = hooi(ten, 'full') compute the full-HOOI
    %
    %   See also.
        N = numel(size(ten));
        [~, U_ten] = nd.hosvd(ten, 'full');
        
        if nargin < 3
            maxIt = 20;
        end
        
        switch Atype
        case 'trunc'
            for it = 1:maxIt
                for ii = 1:N
                    N_mode = 1:N;
                    N_mode(ii) = [];
                    Un = nd.N_mode(ten, U_ten, N_mode);
                    [Ur, Sr, ~] = svd(nd.unfold(Un,ii));
                    if nargin < 3
                        U{ii} = Ur(:,1:rank(Sr));
                    else
                        U{ii} = Ur(:,1:ranksInput(ii));
                    end
                end
            end
        case 'full'
            for it = 1:maxIt
                for ii = 1:N
                    N_mode = 1:N;
                    N_mode(ii) = [];
                    Un = nd.N_mode(ten, U_ten, N_mode);    
                    [Usvd,~,~] = svd(nd.unfold(Un,ii));
                    U{ii} = Usvd;
                end
            end
        end
        S = nd.N_mode(ten, cellfun(@(x) x', U, 'UniformOutput', false)) ; 
    end


    function factors = mlskrf(X, N_mode, order)
    % ND.MLSKRF  Perform the Multidimensional Least-Squares Khatri-Rao 
    %   Factorization (MLSKRF) of a tensor.
    % 
    %   factors = mlskrf(X, N_mode, order) compute the MLSKRF of a tensor
    %
    %   See also.
        [~,R] = size(X);
        factors = cell(N_mode, 1);
        factors_r = cell(R, N_mode);
        for rr = 1:R
            [Sr,Ur] = nd.hosvd(reshape(X(:,rr), flip(order)), 'full');
            for nn = 1:N_mode
                sr = (Sr(1)^(1/N_mode));
                ur = Ur{N_mode-nn+1}(:,1);
                factors_r{rr,nn} = sr*ur;
            end
        end
        for n = 1:N_mode
           factors{n} = reshape(cell2mat(factors_r(:,n)) ,[order(n) R]);
        end
    end

    function Ahat = mlskronf(X, rowsInput, colsInput, Atype)
    % ND.MLSKRONF  Perform the Multidimensional Least-Squares Kronecker 
    %   Factorization (MLS-KronF) of a tensor.
    % 
    %   factors = mlskronf(X, rowsInput, colsInput, Atype) compute the MLSKRF of a tensor
    %
    %   See also.            
        dim = {repelem(rowsInput(2)*rowsInput(3), 1, rowsInput(1)); repelem(colsInput(2)*colsInput(3), 1, colsInput(1))};
        Xb = mat2cell(X,dim{1},dim{2});
        Inv = {flip(rowsInput), flip(colsInput)};
        K = 1;

        for jA = 1:colsInput(1)
            for iA = 1:rowsInput(1)
                dim = {repelem(rowsInput(3), 1, rowsInput(2)), repelem(colsInput(3), 1, colsInput(2))};
                X_bc = mat2cell(cell2mat(Xb(iA,jA)), dim{1}, dim{2});
                for jB = 1:colsInput(2)
                    for iB = 1:rowsInput(2)
                        vb(:,iB,jB) = nd.vec(cell2mat(X_bc(iB,jB)));
                    end
                end
                Xhat(:,K) = reshape(vb,[],1);
                K = K + 1;
            end 
        end
        
        switch Atype
        case 'hosvd'
            [S,U] = nd.hosvd(reshape(Xhat, flip(rowsInput.* colsInput)), 'full');
        case 'hooi'
            [S,U] = nd.hooi(reshape(Xhat, flip(rowsInput.* colsInput)), 'full');
        end
        
        UN = length(U);
        
        for u = 1:UN
            Ahat{UN - u + 1} = reshape((S(1)^(1/length(U)))*U{u}(:,1), [Inv{1}(u) Inv{2}(u)]);
        end
    end


    function [Ahat, Bhat, Chat, error, it] = als(X, R, tol, maxIt)
    % ND.ALS  Perform the Alternating Least-Squares (ALS) of a tensor.
    % 
    %   [Ahat, Bhat, Chat, error, it] = als(X, R, maxIt) compute the MLSKRF of a tensor
    %
    %   See also.            
        
        if nargin < 4
            maxIt = 200;
            if nargin < 3
                tol = 1e-6;
            end
        end
    
        I = size(X); 
        Ahat = nd.randn_complex(I(1), R);
        Bhat = nd.randn_complex(I(2), R);
        Chat = nd.randn_complex(I(3), R);
        X_1 = nd.unfold(X,1);
        X_2 = nd.unfold(X,2);
        X_3 = nd.unfold(X,3);
        
        error = zeros(1,maxIt);
        [error(1), ~] = nd.nmse(X_1, Ahat*(nd.kr_(Chat,Bhat).'));
        
        for i = 2:maxIt
            Bhat = X_2*pinv((nd.kr_(Chat,Ahat)).');
            Chat = X_3*pinv((nd.kr_(Bhat,Ahat)).');
            Ahat = X_1*pinv((nd.kr_(Chat,Bhat)).');
            [error(i), ~] = nd.nmse(X_1, Ahat*(nd.kr_(Chat,Bhat).'));

            if abs(error(i) - error(i-1)) < tol
                error = error(1:i);
                it = i;
                break;
            else
                it = i;
                continue;
            end
        end
    end

    
    %% SAVE DATA TO TXT FILE
    function mat2txt(file, X, permission, header)
    % ND.MAT2TXT  Write a matrix X into a txt file
    %   mat2txt(file, X, 'w', header) - Overwite the file
    %   mat2txt(file, X, 'a', header) - Append to the file end
    %
    %   See also.
        [I, J] = size(X);
        fileID = fopen(file, permission);
        fprintf(fileID, [repelem('-', strlength(header)+3), '\n', header, ...
                '\n', repelem('-', strlength(header)+3), '\n']);
        fprintf(fileID, 'X(%d, %d)\n', I, J);
            for ii = 1:I
                for jj = 1:J
                    fprintf(fileID, ' %2.0f', X(ii,jj));
                end
                fprintf(fileID, ';\n');
            end
        fprintf(fileID, '\n');
        fclose(fileID);
    end

    
    function tensor2txt(file, X, permission, header)
    % ND.TENSOR2TXT  Write a 3D tensor X into a txt file
    %   tensor2txt(file, X, 'w', header) - Overwite the file
    %   tensor2txt(file, X, 'a', header) - Append to the file end
    %
    %   See also.
        [I, J, K] = size(X);
        
        fileID = fopen(file, permission);
        
        fprintf(fileID, [repelem('-', strlength(header)+3), '\n', header, ...
        '\n', repelem('-', strlength(header)+3), '\n']);

        for kk = 1:K
            fprintf(fileID, 'X(:, :, %d)\n', kk);
            for ii = 1:I
                for jj = 1:J
                    fprintf(fileID, ' %2.0f', X(ii,jj,kk));
                end
                fprintf(fileID, ';\n');
            end
            fprintf(fileID, '\n');
        end
        fclose(fileID);    
    end

end

end
##### SOURCE END #####
--></body></html>